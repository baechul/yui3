<div class="intro">
    <p>
        When creating automated tests for your application or modules, you need
        to be able to mock user events.  The DOM supports creating native events
        that behave essentially the same as user generated events, though
        without the associated browser default behaviors (e.g. following a link
        on click).
    </p>
    <p>
        The `event-simulate` module adds the `Y.Event.simulate` method for
        working with raw DOM nodes, but for most cases, the
        `node-event-simulate` module is the right choice, since it allows you
        to call the `simulate` method directly from the `Node`.
    </p>
</div>

<h2>Simulating Mouse Events</h2>

<p>
    There are seven mouse events that can be simulated:
</p>

<ul>
  <li>`click`</li>
  <li>`dblclick`</li>
  <li>`mousedown`</li>
  <li>`mouseup`</li>
  <li>`mouseover`</li>
  <li>`mouseout`</li>
  <li>`mousemove`</li>
</ul>

<p>
    Each event is fired by calling <code>simulate()</code> and passing in two
    arguments: the type of event to fire and an optional object specifying
    additional information for the event. To simulate a click on the document's
    body element, for example, the following code can be used:
</p>

```
YUI().use('node-event-simulate', function(Y) {

    Y.one("body").simulate("click");
});
```

<p>
    This code simulates a click with all of the default properties on the
    <code>event</code> object. To specify additional information, such as the
    Shift key being down, the second argument must be used and the exact DOM
    name for the event property specified (there is browser-normalizing logic
    that translates these into browser-specific properties when necessary):
</p>

```
Y.one("body").simulate("click", { shiftKey: true });
```

<p>
    In this updated example, a click event is fired on the document's body
    while simulating that the Shift key is down.
</p>

<p>
    The extra properties to specify vary depending on the event being simulated
    and are limited to this list:
</p>

<dl>
    <dt>`detail`</dt>
        <dd>
            Indicates the number of times a button was clicked (DOM-compliant
            browsers only).
        </dd>

    <dt>`screenX`, `screenY`</dt>
        <dd>
            Coordinates of the mouse event in relation to the entire screen
            (DOM-compliant browsers only).
        </dd>

    <dt>`clientX`, `clientY`</dt>
        <dd>
            Coordinates of the mouse event in relation to the browser client
            area.
        </dd>

    <dt>`ctrlKey`, `altKey`, `shiftKey`, `metaKey`</dt>
        <dd>
            The state of the Ctrl, Alt, Shift, and Meta keys, respectively
            (true for down, false for up).
        </dd>

    <dt>`button`</dt>
        <dd>
            The button being used for the event, 0 for left (default), 1 for
            right, 2 for center.
        </dd>

    <dt>`relatedTarget`</dt>
        <dd>
            the element the mouse moved from (during a `mouseover` event) or to
            (during a `mouseout` event). 
        </dd>
</dl>

```
YUI().use('node-event-simulate', function(Y) {

    var node = Y.one("#myDiv");

    //simulate a click Alt key down
    node.simulate("click", { altKey: true});

    //simulate a double click with Ctrl key down
    node.simulate("dblclick", { ctrlKey: true });

    //simulate a mouse over
    node.simulate("mouseover", { relatedTarget: document.body });

    //simulate a mouse out
    node.simulate("mouseout", { relatedTarget: document.body });

    //simulate a mouse down at point (100,100) in the client area
    node.simulate("mousedown", { clientX: 100, clientY: 100 });

    //simulate a mouse up at point (100,100) in the client area
    node.simulate("mouseup", { clientX: 100, clientY: 100 });

    //simulate a mouse move at point (200, 200) in the client area
    node.simulate("mousemove", { clientX: 200, clientY: 200 });
});
```

<h2>Simulating Key Events</h2>

<p>There are three key event simulations available:</p>

<ul>
    <li>`keyup`</li>
    <li>`keydown`</li>
    <li>`keypress`</li>
</ul>

<p>
    As with the mouse events, key events are simulated using
    <code>simulate()</code>. For <code>keyup</code> and <code>keydown</code>,
    the <code>keyCode</code> property must be specified; for
    <code>keypress</code>, the <code>charCode</code> property must be included.
    In many cases, <code>keyCode</code> and <code>charCode</code> may be the
    same value to represent the same key (97, for instance, represents the
    &quot;A&quot; key as well as being the ASCII code for the letter
    &quot;a&quot;). For example:
</p>

```
YUI().use('node-event-simulate', function(Y) {

    var node = Y.one("#myDiv");

    //simulate a keydown on the A key
    node.simulate("keydown", { keyCode: 97 });

    //simulate a keyup on the A key
    node.simulate("keyup", { keyCode: 97 });

    //simulate typing "a"
    node.simulate("keypress", { charCode: 97 });
});
```

<p>
    Key events also support the <code>ctrlKey</code>, <code>altKey</code>,
    <code>shiftKey</code>, and <code>metaKey</code> event properties.
</p>
<p>
    <strong>Note:</strong> Due to differences in browser implementations, key
    events may not be simulated in the same manner across all browsers. For
    instance, when simulating a keypress event on a textbox, only Firefox will
    update the textbox with the new character of the key that was simulated to
    be pressed. For other browsers, the events are still registered and all
    event handlers are called, however, the textbox display and
    <code>value</code> property are not updated. These differences should go
    away as browser support for simulated events improves in the future.
</p>

<h2>Simulating UI Events</h2>

<p>There are several UI event simulations available:</p>

<ul>
    <li>`blur`</li>
    <li>`change`</li>
    <li>`focus`</li>
    <li>`resize`</li>
    <li>`scroll`</li>
    <li>`select`</li>
</ul>

<p>
    As with the other events, UI events are simulated using
    <code>simulate()</code>. There are no properties that are required to
    simulate UI events as these events don't carry extra information. Some
    examples:
</p>

```
YUI().use('node-event-simulate', function(Y) {

    var node = Y.one("#myInput");

    //simulate a change event
    node.simulate("change");

    //simulate a select event
    node.simulate("select");
});
```

<h2>Simulating Touch Gestures</h2>
<p>
There are several high level gesture simulations primarily targeting for the 
mobile devices. Single touch gestures such as <code>tap</code>, 
<code>flick</code> are simulated using Mouse Events on desktops or mobile 
devices where creating Touch Events are not supported. All gesture simulations 
are done by calling <code>simulateGesture()</code> method against a YUI Node 
element. The method is asynchronous by default so optionally a callback function 
can be passed. 
</p>

<ul>
   <li>tap - Single touch gesture to simulate a tap. Default is to simulate 
        single tap but it can be configured to tap any number of taps. </li>
   <li>doubletap - Single touch gesture to simulate double taps.</li>
   <li>press - Single touch gesture to simulate long press.</li>
   <li>move - Single touch gesture to simulate the move. It simulates moving 
        one finger straight in any direction. </li>
   <li>flick - Single touch gesture to simulate  the flick gesture. It simulates 
        moving one finger with a certain velocity along either X or Y axis.</li>
   <li>pinch - Two fingers gesture to simulate pinch and spread gestures.</li>
   <li>rotate - Two fingers gesture to simulate rotate gesture.</li>
</ul>

<p>
A set of low level touch events are fired by calling 
<code>simulateGesture()</code> and passing arguments: the name of gestures to 
simulate, an option object specifying additional information to refine gesture 
behavior and optional callback function. The kinds of options varies per 
gesture. If the location of the finger is not given, the framework defaults to 
the center of the node element. User can override this default behavior by 
passing a coordination into the option object. The coordinate values are 
relative to the top/left corner of the node element. 
</p>

<h3>Single Touch Gestures: Tap, Double Tab and Press<h3>

<p>
To simulate various gestures at one point, for example, the following code can 
be used:
</p>
 
```
YUI().use('node-event-simulate', function(Y) {

    var node = Y.one("#myElement");

    //simulate tap gesture.
    node.simulateGesture("tap");

    //simulate double-tap gesture.
    node.simulateGesture("doubletap");

    //simulate press gesture.
    node.simulateGesture("press", {
        hold: 3000    // press and hold for 3000ms (3sec)
    });

    // simulate tap with options and callback.
    node.simulateGesture("tap", {
        point: [30, 30], // tap (30, 30) relative to the top/left of the node.
        hold: 3000,      // hold for 3sec in a tap.
        times: 2,        // tap 2 times.
        delay: 500       // delay time before next tap starts.
    }, function() {
        console.log("I was called.");
    });
});
```
<h4>Valid Options</h4>

<p>
The option properties for <code>tap</code>:
</p>

<dl>
    <dt>`point`</dt>
        <dd>
            Indicates the point(array with X and Y value) where tap should be 
            simulated. Default is the center of the node element.
        </dd>
    <dt>`hold`</dt>
        <dd>
            The hold time in milli-second. This is the time between 
            <code>touchstart</code> and <code>touchend</code> event generation. 
        </dd>
    <dt>`times`</dt>
        <dd>
            Indicates the number of taps. Default is 1.
        </dd>
    <dt>`delay`</dt>
        <dd>
            The delay time in  milli-second before the next tap simulation 
            happens. This is valid only when <code>times</code> is more than 1.
        </dd>
</dl>

<p>
The option properties for <code>doubletap</code>:
</p>

<dl>
    <dt>`point`</dt>
        <dd>
            Indicates the point(array with X and Y value) where tap should be 
            simulated. Default is the center of the node element.
        </dd>
</dl>

<p>
The <code>press</code> gesture is essentially a single tap with 
<code>hold</code> property. The option properties for <code>press</code>:
</p>

<dl>
    <dt>`point`</dt>
        <dd>
            Indicates the point(array with X and Y value) where tap should be 
            simulated. Default is the center of the node element.
        </dd>
    <dt>`hold`</dt>
        <dd>
            The hold time in milli-second. This is the time between 
            <code>touchstart</code> and <code>touchend</code> event generation. 
        </dd>
</dl>

<h3>Single Touch Gestures: Move and Flick<h3>

<p>
To simulate various gestures of moving one finger, for example, the following 
code can be used:
</p>

```
YUI().use('node-event-simulate', function(Y) {

    var node = Y.one("#myElement");

    //simulate move gesture. Move the finger 200 pixels to the positive 
    //X axis(right) direction for approximately 1 second by default.  
    node.simulateGesture("move");

    //simulate move gesture with options. Moves the finger from the center of  
    //the node to the point located 70 pixels more right and 50 pixels lower 
    //than the start point for 2000ms.
    node.simulateGesture("move", {
        path: {
            xdist: 70,
            ydist: -50
        } ,
        duration: 2000
    });

    //simulate flick gesture. Default is flick to right.
    node.simulateGesture("flick");

    //simulate flick gesture with options. Flick to downward by 100 pixels for
    // 50ms.
    node.simulateGesture("flick", {
        axis: y
        distance: -100 
        duration: 50
    });

});
```

<h4>Valid Options</h4>

<p>
The option properties for <code>move</code>:
</p>

<dl>
    <dt>`path`</dt>
        <dd>
            Indicates the path of the finger movement. It's an object with three 
            optional properties: <code>point</code>, <code>xdist</code> and 
            <code>ydist</code>. The <code>point</code> is the start point and 
            default is the center of the node element. It simulates moving the 
            finger from the start point by the given X and Y axis distance in 
            pixels. A negative distance value indicates moving to left for 
            <code>xdist</code> and down for <code>ydist</code>. 
        </dd>
    <dt>`duration`</dt>
        <dd>
            The duration of the gesture in milli-second.
        </dd>
</dl>

<p>
The option properties for <code>flick</code>:
</p>

<dl>
    <dt>`point`</dt>
        <dd>
            Indicates the point(array with X and Y value) where flick should be 
            simulated. Default is the center of the node element.
        </dd>
    <dt>`axis`</dt>
        <dd>
            Valid values are either "x" or "y". Indicates moving axis. The flick 
            moves to only 4 directions(left, right, up and down).
        </dd>
    <dt>`distance`</dt>
        <dd>
            Moving distance in pixels.  
        </dd>
    <dt>`duration`</dt>
        <dd>
            The duration of the gesture in milli-second. The duration could be 
            automatically adjusted by the framework if the velocity is 
            calculated below the minimum velocity to be a flick gesture.  
        </dd>
</dl>

<h3>Tow Finger Gestures: Pinch and Rotate<h3>

<p>
The <code>pinch</code> gesture is used for pinch and spread of 2 fingers. 
While pinching, rotation simulation is also possible. Essentially 
<code>pinch</code> and <code>rotation</code> gesture simulations share the same 
base implementation to allow both pinching and rotation at the same time. Only
difference is <code>pinch</code> requires start and end radius while 
<code>rotation</code> requires a degree to rotate in the option object. 
The <code>pinch</code> and <code>rotation</code> gesture movement is 
characterized using circles where 2 fingers are on the circle across. The pinch 
and spread gestures requires start and end circles while rotation gesture is 
simulated on a circle. If the radius of start circle is greater than one of end 
circle, it would be pinch gesture otherwise spread gesture.
</p>

<p>
To simulate two finger gestures, for example, the following 
code can be used:
</p>

```
YUI().use('node-event-simulate', function(Y) {

    var node = Y.one("#myElement");

    //simulate pinch gesture. Both "r1" and "r2" are required.
    node.simulateGesture("pinch", {
        r1: 100, // start circle radius at the center of the node.
        r2: 50   // end circle radius at the center of the node. 
    });

    //simulate spread gesture. 
    //note that the same gesture name, "pinch" is used but r2(end circle radius)
    //is greater than r1.
    node.simulateGesture("pinch", {
        r1: 50,
        r2: 100
    });

    //simulate rotate gesture. The "rotation" option is required.
    //rotate the node 75 degree counter-clock direction. 
    node.simulateGesture("rotate", {
        rotation: -75
    });

    //simulate pinch and rotations at the same time. In the beginning, the first 
    //finger is on the circle of 100 radius and 45 degree. Other finger is
    //always located across the center of the circle. When the gesture ends, the
    //first finger will be on the circle of 50 radius and heading to the exact 
    //south(90 degree). 
    node.simulateGesture("pinch", {
        r1: 100,
        r2: 50,
        start: 45
        rotation: 45
    });
});
```
<h4>Valid Options</h4>

<p>
The option properties are same for <code>pinch</code> and <code>rotation</code> 
gesture simulations.
</p>

<dl>
    <dt>`center`</dt>
        <dd>
            The center of the circles where 2 fingers are on its circumference
            across. Default is the center of the node element.
        </dd>
    <dt>`r1`</dt>
        <dd>
            Required for <code>pinch</code> gesture type but optional for <code>
            rotation</code> type. A radius of the start circle. If omitted in 
            <code>rotation</code> gesture type, default is the half of the node
            element width or height whichever is smaller.
        </dd>
    <dt>`r2`</dt>
        <dd>
            Required for <code>pinch</code> gesture type but optional for <code>
            rotation</code> type. A radius of the end circle. If omitted in 
            <code>rotation</code> gesture type, default is the half of the node
            element width or height whichever is smaller.
        </dd>
    <dt>`duration`</dt>
        <dd>
            The duration of the gesture in milli-second.
        </dd>
    <dt>`start`</dt>
        <dd>
            A start degree of the first finger for the rotation gesture. Default  
            is 0. The angle value are relative to the 12 O'clock direction.
        </dd>
    <dt>`rotation`</dt>
        <dd>
            A degree to rotate from the start degree. Negative value means 
            rotation of counter-clock direction.
        </dd>
</dl>

<h3>Gesture Simulation on iOS</h3>
<p>
If the gesture simulation is called in iOS, it generates not just touch events 
but also <a href="http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/GestureEventClassReference/GestureEvent/GestureEvent.html">
iOS specific gesture events</a> under the hood: <code>gesturestart</code>, 
<code>gesturechange</code> and <code>gestureend</code>.
</p>

<h3>Customizing Default Gesture Properties</h3>

<p>
If you want to rely on the default behavior instead of passing various options 
whenever gesture APIs are called but framework's default value doesn't work for 
you, your own default behavior properties can be set to 
<code>Y.GestureSimulation.defaults</code> object. Here are the properties of 
defaults object:  
</p>

<ul>
    <li>HOLD_TAP</li>
    <li>DELAY_TAP</li>
    <li>HOLD_PRESS</li>
    <li>MIN_HOLD_PRESS</li>
    <li>MAX_HOLD_PRESS</li>
    <li>DISTANCE_MOVE</li>
    <li>DURATION_MOVE</li>
    <li>MAX_DURATION_MOVE</li>
    <li>MIN_VELOCITY_FLICK</li>
    <li>DISTANCE_FLICK</li>
    <li>DURATION_FLICK</li>
    <li>MAX_DURATION_FLICK</li>
    <li>DURATION_PINCH</li>
</ul>

<p>
And an example:
</p>

```
YUI().use('node-event-simulate', function(Y) {

    var node = Y.one("#myElement");
    
    Y.GestureSimulation.defaults = Y.merge(Y.GestureSimulation.defaults, {
        HOLD_TAP: 3000
    });
    
    //now touchend event will be generated after 3 sec from the touchstart 
    //event generation.
    node.simulateGesture("tap");
});
```

<h2>Caveats and Coming Soons</h2>

<h3 id="faking">Don't use simulation in user facing code</h3>

<p>
    Event simulation is for automated testing.  Your application should respond
    to real user events.  For reasons
    <a href="#only-what-you-ask-for">mentioned below</a>, it can be easy to get
    your application into a confused runtime state when some callbacks have
    been executed but not others.
</p>

<p>
    Typically, event simulation is sought to trigger certain callbacks.  If a
    function needs to respond to user action or be called programmatically, it
    should be written accordingly and called directly in the latter case.
    Often a better solution is to extract the core logic from the event handler
    into a separate function and call that method from the event handler and
    from the other part of the application that was going to use simulation.
</p>

<p>
    In some cases, simulation is wanted because there may be any number of
    subscriptions on a node, and all applicable callbacks should be triggered.
    If this is the case, investigate using <a
    href="../event-custom/index.html">custom events</a>, instead.
</p>

<p>
    The bottom line is, reliance on event simulation in production code is a
    warning sign that the architecture is not scaling.  The affected code
    should be refactored before it becomes a larger problem.
</p>

<h3>Only what you ask for</h3>

<p>
    In many cases, events happen in groups (`mousedown`, `mouseup`, `click`, or
    `keydown`, `keyup`, `keypress`).  If you simulate an event that is
    typically part of a group or is often followed by other events, <em>the
    other events will NOT be generated</em> for free.
</p>

<p>
    For example, if you simulate a `click` event on a submit button, you only
    simulate the `click` event.  The preceding `mousedown` and `mouseup`, as
    well as the subsequently expected 'submit' are neither simulated or fired
    natively.
</p>

<h3>No touch events yet</h3>

<h3>No synthetic event simulation yet</h3>

<p>
    The <a href="synths.html">Synthetic event system</a> doesn't yet support
    defining simulation. In most cases, though, synthetic events are triggered
    by other DOM events that can be simulated, so it's often possible to
    trigger them by simulating the underlying events.  But that ignores the
    point that synthetic events are supposed to mask that abstraction for your
    benefit.
</p>

<p>
    Support for synthetic event simulation is on the roadmap.
</p>
